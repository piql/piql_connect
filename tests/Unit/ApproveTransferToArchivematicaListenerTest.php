<?php

namespace Tests\Unit;

use App\Bag;
use App\Events\ApproveTransferToArchivematicaEvent;
use App\Events\ArchivematicaTransferringEvent;
use App\Events\ErrorEvent;
use App\Listeners\ApproveTransferToArchivematicaListener;
use App\Listeners\ArchivematicaClient;
use Illuminate\Foundation\Bus\PendingDispatch;
use Illuminate\Queue\CallQueuedClosure;
use Illuminate\Queue\SerializableClosure;
use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Event;
use PhpParser\Node\Expr\Closure;
use Tests\TestCase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Mockery;

class ApproveTransferToArchivematicaListenerTest extends TestCase
{

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

    }

    protected function tearDown(): void
    {
        parent::tearDown(); // TODO: Change the autogenerated stub
    }

    public function test_ApproveTransferToArchivematicaListener_success() {
        Event::fake();
        Bus::fake();
        $bag = Mockery::mock(Bag::class);
        $bag->shouldReceive('applyTransition')->once();
        $bag->shouldReceive('save')->once();
        $bag->shouldReceive('zipBagFileName')->twice()->andReturn('test.zip');
        $bag->shouldReceive('getAttribute')->twice()->andReturn("007");

        $amClient = \Mockery::mock(ArchivematicaClient::class);

        $status = json_decode('{"results":[{"name":"test.zip"}]}');
        $amClient->shouldReceive('getTransferStatus')
            ->once()->andReturn($status);

        $amClient->shouldReceive('approveTransfer')->once();

        $event = new ApproveTransferToArchivematicaEvent($bag);
        $listener = new ApproveTransferToArchivematicaListener($amClient);
        $listener->handle($event);

        Bus::assertNotDispatched(CallQueuedClosure::class, function ($job) {
            return true;
        });

        Event::assertDispatched(ArchivematicaTransferringEvent::class);
        Event::assertNotDispatched(ApproveTransferToArchivematicaEvent::class);
    }

    public function test_ApproveTransferToArchivematicaListener_archivematica_client_error() {
        Event::fake();
        Bus::fake();
        $bag = Mockery::mock(Bag::class);
        $bag->shouldReceive('applyTransition')->once();
        $bag->shouldReceive('save')->once();
        $bag->shouldReceive('zipBagFileName')->once()->andReturn('test.zip');
        $bag->shouldReceive('getAttribute')->once()->andReturn("007");

        $amClient = \Mockery::mock(ArchivematicaClient::class);

        $status = json_decode('{"message":"error", "results":[]}');
        $amClient->shouldReceive('getTransferStatus')
            ->once()->andReturn($status);

        $amClient->shouldReceive('approveTransfer')->never();

        $event = new ApproveTransferToArchivematicaEvent($bag);
        $listener = new ApproveTransferToArchivematicaListener($amClient);
        $listener->handle($event);


        Bus::assertDispatched(CallQueuedClosure::class, function ($job) {
            return true;
        });

        Event::assertNotDispatched(ArchivematicaTransferringEvent::class);
        Event::assertNotDispatched(ErrorEvent::class);
    }

    public function test_ApproveTransferToArchivematicaListener_archivematica_status_missing() {
        Event::fake();
        Bus::fake();
        $bag = Mockery::mock(Bag::class);
        $bag->shouldReceive('applyTransition')->once();
        $bag->shouldReceive('save')->once();
        $bag->shouldReceive('zipBagFileName')->twice()->andReturn('test.zip');
        $bag->shouldReceive('getAttribute')->once()->andReturn("007");

        $status = json_decode('{"results":[{"name":"test2.zip"}]}');
        $amClient = \Mockery::mock(ArchivematicaClient::class);
        $amClient->shouldReceive('getTransferStatus')
            ->once()->andReturn($status);
        $amClient->shouldReceive('approveTransfer')->never();

        $event = new ApproveTransferToArchivematicaEvent($bag);
        $listener = new ApproveTransferToArchivematicaListener($amClient);
        $listener->handle($event);


        Bus::assertDispatched(CallQueuedClosure::class, function ($job) {
            return true;
        });

        Event::assertNotDispatched(ArchivematicaTransferringEvent::class);
        Event::assertNotDispatched(ErrorEvent::class);
    }

    public function test_ApproveTransferToArchivematicaListener_bag_state_transition_error() {
        Event::fake();
        Bus::fake();
        $bag = Mockery::mock(Bag::class);
        $bag->shouldReceive('applyTransition')->once();
        $bag->shouldReceive('save')->once();
        $bag->shouldReceive('zipBagFileName')->twice()->andReturn('test.zip');
        $bag->shouldReceive('getAttribute')->times(3)->andReturn("007");

        $amClient = \Mockery::mock(ArchivematicaClient::class);

        $status = json_decode('{"results":[{"name":"test.zip"}]}');
        $amClient->shouldReceive('getTransferStatus')
            ->once()->andReturn($status);

        $amClient->shouldReceive('approveTransfer')->once()->andThrow(new \Exception(""));

        $event = new ApproveTransferToArchivematicaEvent($bag);
        $listener =new ApproveTransferToArchivematicaListener($amClient);
        $listener->handle($event);

        Bus::assertNotDispatched(CallQueuedClosure::class, function ($job) {
            return true;
        });

        Event::assertNotDispatched(ArchivematicaTransferringEvent::class);
        Event::assertDispatched(ErrorEvent::class);
    }

}
